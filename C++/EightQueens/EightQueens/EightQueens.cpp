// Honer Code
// 我真诚地保证：
// 我自己独立地完成了整个程序从分析、设计到编码的所有工作。
// 如果在上述过程中，我遇到了什么困难而求教于人，那么，我将在程序实习报告中
// 详细地列举我所遇到的问题，以及别人给我的提示。
// 我的程序里中凡是引用到其他程序或文档之处，
// 例如教材、课堂笔记、网上的源代码以及其他参考书上的代码段,
// 我都已经在程序的注释里很清楚地注明了引用的出处。
// 我从未没抄袭过别人的程序，也没有盗用别人的程序，
// 不管是修改式的抄袭还是原封不动的抄袭。
// 我编写这个程序，从来没有想过要去破坏或妨碍其他计算机系统的正常运转。
// 签署人：计类1801 张京宇 2018011140

// 程序文档
// 文件名称：EightQueens.cpp
// 项目名称：EightQueens
// 创建者：张京宇
// 创建时间：2019.10.15
// 最后修改时间：2019.10.17
// 功能：八皇后主算法&主函数

#include "EQ.h"; // 导入头文件

int A[N]; // 用一维数组代表皇后

int main()
{
	int num = 0; // 解法计数器
	int checknum = 0; // 判断皇后冲突用的数值计数器
	for (int i = 0; i < N; i++) // 初始化皇后位置
	{
		A[i] = 0;
	}
	while (true) // 开始循坏
	{
		for (int i = 0; i < N; i++) // 一层循环，每次循环完成摆好一个皇后（行循环）
			{
				for (int j = 0 ; j < i ; j++) // 二层循环，单个皇后与已摆好的皇后进行冲突判断，不满足平衡条件时，列位置向下移动一格
				{
					if (A[i] >= N) // 皇后超出棋盘
					{
						A[i] = 0;
						A[i - 1]++;
						i--;
						j = -1;
					}
					else if (!checkQueens(i,j)&&(i != 0)) // 检查皇后是否与已摆好的皇后冲突
					{
						A[i]++;
						j = -1;
					}
				}
			}
		// 当第一个皇后到达棋盘底端时结束程序
		if (A[0] > N - 1) {
			break;
		}
		for (int e = 0; e < N; e++) // 打印结果
		{
			cout << "(" << e << "," << A[e] << ")" << " ";
		}
		cout << endl;
		num++;A[N-1]++;
	}
	printf("%d个皇后，不考虑棋盘对称性，共%d种解法\n",N,num); // 提示语
	return 0;
}

bool checkQueens(int i ,int j) {
	if ((A[i] + i == A[j] + j) || (A[i] == A[j]) || (A[i] - i == A[j] - j)) // 皇后冲突
	{
		return false;
	}
	else // 皇后不冲突
	{
		return true;
	}
}